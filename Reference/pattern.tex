Function definitions with pattern matching may involve clauses that are unreachable or redundant. The patterns may also not be exhaustive. We want to warn users of all these cases. We implement a pattern matching coverage check that checks for all these cases. See the $\boldsymbol{src/Coverage}$ directory for the implementation.

\subsection{Split Trees}

After the patterns are type checked (as in section \ref{sec:typeCheckPattern}), we transform the clauses into a \textit{split tree}. See $\boldsymbol{SplitTree.hs}$.

Each split tree is associated with either 

\begin{enumerate}
  \item a constructor ($SplitCon$)
  \item a literal ($SplitLit$)
  \item a catchall branch ($SplitCatchall$)
\end{enumerate}

A $SplitTag$ is added to each split tree to include this information. 

Each node of the split tree is either at an end ($SplittingDone$) or there is another split ($SplitAt$), which has sub-split trees for each of the constructors (of type $SplitTrees' a$, which is a list of constructor names and split trees mapping).

\subsection{Coverage Algorithm}

This algorithm works on function definitions with overlapping clauses. When two clauses overlap, the top most clause takes priority.

Given the list of clauses provided by the user, we compute a single \textit{covering} from a sequence of exhaustive but possibly overlapping clauses.

To compute a covering, we first compute \textit{an elementary covering}.

\subsubsection{Elementary and General Covering}

For full details see \textit{Pattern Matching with Dependent Types} by Thierry Coquand.

An \textit{elementary covering} of a common context $\Delta = x_1 : A_1,...x_n : A_n$ is a system of context mappings $S_1 : \Gamma_1 \to \Delta, ..., S_m : \Gamma_m \to \Delta$ iff there exists an index $\boldsymbol{i < n}$ such that

\begin{enumerate}
  \item all terms $x_iS_j : A_iS_j(\Delta_j)$, for $j \leq m$, are in constructor form and
  \item if $S : \Gamma \to \Delta$ is a context mapping such that $x_iS$ is in constructor form, then there exists one and only one $j \leq m$ and $T : \Gamma \to \Gamma_j$ such that $S=T;S_j$.
  
\end{enumerate}

For example, the context mappings

\begin{itemize}
  \item $x = 0$
  \item $x = succ(y) (y : N)$
\end{itemize}

is the elementary covering of the context $x : N$

A \textit{covering} of a common context $\Delta$ is a system of context mappings $S_i : \Delta_i \to \Delta$ if

\begin{enumerate}
  \item the identity interpretation $\Delta -> \Delta$ is a covering of $\Delta$ and
  \item if $S : \Gamma \to \Delta$ is a context mapping such that $x_iS$ is in constructor form, then there exists one and only one $j \leq m$ and $T : \Gamma \to \Gamma_j$ such that $S = T;S_j$. 
\end{enumerate}

For example, the following context mappings are a covering of the context $\boldsymbol{\Delta = x : N, y : N}$

\begin{itemize}
  \item ${x := 0} : (y : N) \to \Delta$,
  \item ${x := succ(x_1), y:= 0} : (x_1 : N) \to \Delta$ and
  \item ${x := succ(x_1), y:= succ(y_1)} : (x_1 : N, y_1 : N) \to \Delta$
\end{itemize}

A \textit{neighbourhood} of a context is any context mapping that is part of a covering of this context. For example, 

\[
  {x := 0} : (y : N) \to \Delta
\] is a neighbourhood of context $\Delta$ in the above example.

\subsubsection{Building a Covering}

To build a covering of context 

\[\Delta = x_1 : A_1, ..., x_n : A_m\], we first build elementary coverings by \textit{splitting the context $\Delta$ along i}, where $i \leq n$ and $A_i$ is a small type.

If $A_i$ is not a small type or if it is not in constructor form, then the algorithm fails to produce any covering.

Otherwise, we list all the constructors of type $A_i$ and perform unification. This generates a set of new context mappings where $x_i$ has been instantiated with an application of each of the constructors to fresh variables. (See $matchPat$ in $\boldsymbol{Match.hs}$)

