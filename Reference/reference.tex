%
% The first command in your LaTeX source must be the \documentclass command.
\documentclass[acmsmall]{acmart}
% clear acmtog.cls footer settings
\fancyfoot{}
\setcopyright{none}
\renewcommand\footnotetextcopyrightpermission[1]{}
\pagestyle{plain}
%remove reference format
\settopmatter{printacmref=false}
%
\usepackage{hyperref}
\begin{document}

\title{A Totality Checker for a Dependently Typed Language}

%
% The "author" command and its associated commands are used to define the authors and their affiliations.
% Of note is the shared affiliation of the first two authors, and the "authornote" and "authornotemark" commands
% used to denote shared contribution to the research.
\author{Marty Stumpf}
\email{thealmartyblog@gmail.com}

%
% Keywords. The author(s) should pick words that accurately describe the work being
% presented. Separate the keywords with commas.
%\keywords{functional programming, dependent type, type checker, termination checking, totality checking}

%
%
% This command processes the author and affiliation and title information and builds
% the first part of the formatted document.
\maketitle
\thispagestyle{empty}
\tableofcontents
\clearpage
\section{Introduction}

This is the reference document for the
\href{https://github.com/thealmarty/totality-checker}{totality-checker}
repository, which is a totality checker for a dependently typed language
implemented in Haskell. The totality checker checks:

\begin{enumerate}
  \item strict positivity of constructors
  \item pattern matching coverage
  \item termination
\end{enumerate}

To support these checks, the type checker has to support data type (hence the
strict positivity) and function (hence the pattern matching coverage)
declarations. I first describe the type checker without totality checks in
section \ref{sec:prelim}. Then I describe the mechanism for checking strict positivity
in section \ref{sec:spos}. After that, I describe the mechanism for checking
termination in section \ref{sec:termination}. Finally, I describe the mechanism
for checking the patterns of a function cover all cases in section
\ref{sec:pattern}.

\section{type checking without totality checks}
\label{sec:prelim}
The type checker checks \emph{data type} and \emph{function} declarations. These declarations
consist of \emph{expressions}. Because of dependent types, we need to \emph{evaulate} expressions to \emph{values} during type checking. We also need a \emph{signature} that collects and carries information about the declarations during type checking.

\subsection{Expressions}

An expression $e$ is one of the following (as in $Types.hs$):

\begin{equation*}
  \begin{aligned}
    e &  & = &  & \star              &  & \textrm{universe of small types} \\
      &  & | &  & x                  &  & \textrm{variable (name)}         \\
      &  & | &  & c                  &  & \textrm{constructor (name)}      \\
      &  & | &  & D                  &  & \textrm{data type (name)}        \\
      &  & | &  & f                  &  & \textrm{function (name)}         \\
      &  & | &  & \lambda x.e        &  & \textrm{abstraction}             \\
      &  & | &  & (x:A) \to B        &  & \textrm{dependent function type} \\
      &  & | &  & e \: e_1 \dots e_n &  & \textrm{application}             \\
  \end{aligned}
\end{equation*}

\subsubsection{Functions}

A function declaration $f$ is a sequence of function \emph{clauses}. 

A clause consists of a sequence of \textrm{patterns} $p$, which are
arguments to the function, and the right hand side expression $e$:  

\begin{figure}[H]
  \begin{equation*}
    f \: (p_1 \dots p_n) = e
  \end{equation*}
  \caption{A Clause}
\end{figure}

A pattern $p$ is either a variable pattern, a constructor pattern (which
consists of patterns), or an inaccessible pattern:

\begin{figure}[H]
  \begin{equation*}
    \begin{aligned}
      p &  & = &  & x                    &  & \textrm{variable pattern}     \\
        &  & | &  & c \: (p_1 \dots p_n) &  & \textrm{constructor pattern}  \\
        &  & | &  & \underline{e}        &  & \textrm{inaccessible pattern} \\
    \end{aligned}
  \end{equation*}
  \caption{Patterns}
\end{figure}

\subsection{Values}

Because of dependent types, computation is required during type-checking. An
expression $e$ in an environment $\rho$ is \emph{evaluated} during type-checking to a type or a \emph{value} $v$.

Environments provide bindings for the free variables occurring in the
corresponding $e$. Thus, an environment $\rho$ is a list of pairs of variable and its type. Values of abstractions, dependent functions, and applications contain \emph{closures}. A closure $\boldsymbol{e^{\rho}}$ is a pair of an expression $e$ and an
\emph{environment} $\boldsymbol{\rho}$.

\begin{figure}[H]
  \begin{equation*}
    \label{eq:values}
    \begin{aligned}
      v &  & = &  & v \: (v_1 \dots v_n)     &  & \textrm{application}              \\
        &  & | &  & Lam \: x \: e^{\rho}     &  & \textrm{abstraction}              \\
        &  & | &  & Pi \: x \: v \: e^{\rho} &  & \textrm{dependent function space} \\
        &  & | &  & k                        &  & \textrm{generic value}            \\
        &  & | &  & \star                    &  & \textrm{universe of small types}  \\
    \end{aligned}
  \end{equation*}
  \caption{Values}
\end{figure}

$v \: (v_1 \dots v_n)$, $Lam \: x \: e^{\rho}$, and $Pi \: x \: v \: e^{\rho}$
can be evaluated further (see below) while $k$, $\star$, $c$, $f$, and $D$ are \emph{atomic values}
which cannot be evaluated further. A generic value $k$ represents the value of a variable during type
checking. $k \in$ integer, starts from 1. It is also used to collect inaccessible patterns during type checking. More below. 

\subsection{Signature}
A signature $\Sigma$ carries information about all declared constants (constructors, data types, and functions). Each declaration adds newly defined constants to the signature, which is empty at the beginning. Each declaration that is added to the signature is a mapping of the constant to its information, including the evaluated value (type) of the constant. Specifically, a mapping in the signature maps:

\begin{itemize}
  \item a \textbf{function} to
        \begin{enumerate}
          \item its type
          \item its clauses
          \item a boolean indicating whether the clauses have been type-checked,
        \end{enumerate}
  \item a \textbf{constructor} to its type,
  \item a \textbf{data type} to its type and the number of parameters.
\end{itemize}

\begin{figure}[H]
  \begin{equation*}
    \begin{aligned}
      \Sigma f & : & (\textrm{value, a sequence of clauses, boolean}) \\
      \Sigma c & : & \textrm{value}                                   \\
      \Sigma D & : & (\textrm{value, integer})                        \\
    \end{aligned}
  \end{equation*}
  \caption{Mapping types in a Signature}
\end{figure}

The signature is in a \emph{state} monad so that we can retrieve the signature during type and totality checking. The mapping of a constant may be added before the constant is type-checked. For a function constant, the mapping contains the information about whether the clauses have been type-checked or not.

\subsection{Evaluations}

The $eval$ function evaluates an expression $e$ in environment $\rho$ to a
$value$ as follows (see $Evaluator.hs$):

\begin{figure}[H]
  \begin{equation*}
    \begin{aligned}
      eval \: (\lambda x . e)^{\rho}   & = & Lam \: x \: e^{\rho}                                            \\
      eval \: ((x:A) \to B)^{\rho}     & = & Pi \: x \: v_A \: B^{\rho}                                      \\
                                       &   & \textrm{ where } v_A = eval \: A^{\rho}                         \\
      eval \: (e e_1 \dots e_n)^{\rho} & = & app \: v \: v_1 \dots v_n                                       \\
                                       &   & \textrm{ where } v = eval \: e^{\rho}, v_i = eval \: e_i^{\rho} \\
      eval \: (\star)^{\rho}           & = & \star                                                           \\
      eval \: c^{\rho}                 & = & c                                                               \\
      eval \: f^{\rho}                 & = & f                                                               \\
      eval \: x^{\rho}                 & = & \textrm{ value of } x \textrm{ in } \rho                        \\
    \end{aligned}
  \end{equation*}
  \caption{Evaluation of Expressions}
\end{figure}

The closures in $Lam \: x \: e^{\rho}$, and $Pi \: x \: v \: e^{\rho}$ do not have a
binding for $x$. If there is no concrete value, a fresh generic value $k$ would be
the binding for $x$ so that the closures can be evaluated.

When possible, we perform $\beta$-reduction and inductive function application. The $app$ function takes in a $value$ as the first argument and a sequence of
$value$s as the second argument, and returns a $value$: 

\begin{figure}[H]
  \begin{equation*}
    \begin{aligned}
      app \: u \: ()                                             & = & u                                                      \\
      app \: (u \: c_{11} \dots c_{1n}) \: (c_{21} \dots c_{2n}) & = & app \: u \: (c_{11} \dots c_{1n}, c_{21} \dots c_{2n}) \\
      app \: (Lam \: x \: e^{\rho}) \: (v,(v_1 \dots v_n))       & = & app \: v' \: (v_1 \dots v_n)                           \\
                                                                 &   & \textrm{ where } v' = eval \: e^{\rho,x=v}             \\
      app \: f \: (v_1 ... v_n)                                  & = & app_{fun} \: f \: (v_1 \dots v_n)                      \\
                                                                 &   & \textrm{ if } f \textrm{ is a function }               \\
    \end{aligned}
  \end{equation*}
  \caption{$\beta$-Reduction and Inductive Function Application}
\end{figure}

Regarding $app_{fun}$: when the first argument of $app$ is a function, we need to type-checked each
clause of the function and thus pattern matching is required before we can evaluate $app$ further.

\subsubsection{Pattern Matching and $app_{fun}$}

To perform inductive function application, we need to find a clause that matches all patterns. We match all clauses
of the function until we find the clause. To match the clauses, we need to match all patterns of
each clause. 

If all patterns of a clause match against the argument values (checked by $match$ and $matchList$), then
the right hand side can be evaluated (by $match_{clause}$). 

The sequence of clauses is then matched against the evaluated right hand side values (by $match_{cls}$).

The function $match$ takes three arguments:

\begin{enumerate}
  \item an environment $\rho$
  \item a pattern $p$
  \item a value $v$
\end{enumerate}

When the pattern is \textbf{inaccessible}, it returns the input environment.

When the pattern is a \textbf{variable}, it returns an environment that binds the variables in the patterns to values ($x$ to $v$) .

When the pattern is a \textbf{constructor}, it returns the input environment if the constructor name(s) match(s) the input value.

\begin{figure}[H]
  \begin{equation*}
    \begin{aligned}
      match \: \rho \: \underline{e} \: v                               & = & \rho                                                 \\
      match \: \rho \: x \: v                                           & = & \rho \textrm{ with } (x, v) \textrm{ added.}         \\
      match \: \rho \: (c \: ()) \: c                                   & = & \rho                                                 \\
      match \: \rho \: (c \: (p_1 \dots p_n)) \: (c \: (v_1 \dots v_n)) & = & matchList \: \rho (p_1 \dots p_n) \: (v_1 \dots v_n) \\
    \end{aligned}
  \end{equation*}
  \textrm{ where }
  \begin{equation*}
    \begin{aligned}
      matchList \: \rho \: () \: ()                        & = & \rho                                                                               \\
      marchList \: \rho \: (p_1 \dots) \: e \: (v_1 \dots) & = & matchList \: \rho' \:(p_2 \dots) \: (v_2 \dots)                                    \\
                                                           &   & \textrm{ where } \rho'                               = match \: \rho \: p_1 \: v_1 \\     
    \end{aligned}
  \end{equation*}
  \caption{Pattern Matching}
\end{figure}

Pattern matching can fail and no environment is returned in such case. $match$ is used in $match_{clause}$, which evaluates and returns the type of the right hand side expression of a given clause.

The function $match_{clause}$ takes in four arguments:

\begin{enumerate}
  \item an environment $\rho$, which contains the variables in the matched patterns.
  \item a sequence of patterns $(p_1 \dots p_n)$
  \item the right hand side expression $e$
  \item a sequence of values $(v_1 \dots v_n)$
\end{enumerate}

It only returns a $value$ if $match$ returns an environment:

\begin{figure}[H]
  \begin{equation*}
    \begin{aligned}
      match_{clause} \: \rho \: () \: e \: (v_1 \dots v_n)      & = & app \: v \: (v_1 \dots v_n)                                \\
                                                                &   & \textrm{ where } v = eval \: e^{\rho}                      \\
      match_{clause} \: \rho \: (p_1 \dots) \: e \: (v_1 \dots) & = & match_{clause} \: \rho' \: (p_2 \dots) \: e \: (v_2 \dots) \\
                                                                &   & \textrm{ where } \rho' = match \: \rho \: p_1 \: v_1       \\                                                        
    \end{aligned}
  \end{equation*}
  \caption{Matching All Patterns of a Single Clause}
\end{figure}

If all the patterns are matched in a clause, then it returns the $value$ of the application with the right hand side $e$ evaluated. If any of the patterns doesn't match, nothing is returned.

$match_{cls}$ takes a sequence of clauses and a sequence of values as input and returns the matched clause's value:

\begin{figure}[H]
  \begin{equation*}
    \begin{aligned}
      match_{cls} \: ((f \: (p_1 \dots p_n) = e), clause_2, \dots) \: (v_1 \dots v_n) & = & v                                                               \\
      \textrm{ where } v                                                              & = & match_{clause} \: () \: (p_1 \dots p_n) \: e \: (v_1 \dots v_n) \\
      match_{cls} \: ((f \: (p_1 \dots p_n) = e), clause_2, \dots) \: (v_1 \dots v_n) & = & match_{cls} \: (clause_2 \dots) \: (v_1 \dots v_n)              \\
    \end{aligned}
  \end{equation*}
  \caption{Matching All Clauses}
\end{figure}

Each clause is tried until one is matched or there are no clauses left. If there are no clauses left to match, then we failed to find a clause that matches all the patterns and nothing is returned. If nothing is returned, $app_{fun}$ cannot be reduced further. If a value is returned, and all clauses are type-checked (see section \ref{sec:typeCheckPattern}), then we can apply the function. We reduce $app_{fun}$ as follows:

\begin{figure}[H]
  \begin{equation*}
    \begin{aligned}
      app_{fun} \: f \: (v_1 \dots v_n) & =             & v                                                               \\
                                        & \textrm{ if } & \Sigma f = (t, (clause_1 \dots clause_n), True)                 \\
                                        & \land         & v = match_{cls} \: (clause_1 \dots clause_n) \: (v_1 \dots v_n) \\
    \end{aligned}
  \end{equation*}
  \caption{$app_{fun}$}
\end{figure}

\subsection{Type Checking of Expressions}

Recall that declarations consist of expressions. Type checking a declaration therefore comprises type checking expressions. See $CheckExpr.hs$. 

We use the bidirectional type checking technique. The type-checker has two modes:

\begin{enumerate}
  \item $checkExpr$ checks that the input expression $e$ is of type $v$.
  \item $inferExpr$ infers the type of the input expression.
\end{enumerate}

$checkExpr$ uses $inferExpr$ as needed to infer the type of the input expression and check that it is \emph{equal} to the input type. $eqVal$ defines the equality of two values.

$checkExpr$, $inferExpr$, and $eqVal$ are simultanously defined in the next sections. They all return a state transformer monad $StateT \: Signature \: IO \: a$. The state is the signature, which contains information for type checking of data type/function declarations. The inner monad is the $IO$ monad. 

$a$ is $unit$ for $checkExpr$ and $eqVal$. If no error occurs, each step of the $IO$ returns $()$. $a$ is $value$ for $inferExpr$, because $inferExpr$ returns the type of the input expression.

\subsubsection{$checkExpr$}
\label{sec:checkExpr}

$checkExpr$ takes 5 arguments:

\begin{enumerate}
  \item $k$, the subjected generic value.
  \item environment $\rho$, which is a list of pairs of $n$ (variable name) and $k$ that binds a fresh generic value to a variable.
  \item environment $\Gamma$, which is a list of pairs of $n$ and $v$ that binds the type value to a variable.
  \item expression $e$, the expression being checked.
  \item value $v$, the supposed type of the expression.
\end{enumerate}

If the expression does not have a type equal $v$, an error occurs. Unless an error occurs, it returns a $unit$.

\begin{figure}[H]
  \begin{equation*}
    \begin{aligned}
      checkExpr \: k \: \rho \: \Gamma \: (\lambda \: x.e) \: v  & = & checkExpr \: (k + 1) \: \rho' \: \Gamma' \:e \: v'          \\
                                                                 &   & \textrm{ where } v = Pi \: y \: v_A \: t^{\rho}             \\ 
                                                                 &   & \rho' = \rho : (x, k),                                      \\
                                                                 &   & \Gamma' = \Gamma : (x, v_A),                                \\
                                                                 &   & v' = eval \: t^{\rho:(y, k)}                                \\
      checkExpr \: k \: \rho \: \Gamma \: ((x:A) \to B) \: \star & = & checkExpr \: k \: \rho \: \Gamma A \star              \land \\
                                                                 &   & checkExpr \: (k+1) \: \rho' \: \Gamma' \: B \: \star        \\
                                                                 &   & \textrm{ where } \rho' = \rho : (x, k),                     \\
                                                                 &   & \Gamma' = \Gamma:(x, eval \: A^{\rho}).                     \\
      checkExpr \: k \: \rho \: \Gamma \: e \: v                 & = & eqVal \: k \: (inferExpr \: k \: \rho \: \Gamma \: e) \: v  \\
    \end{aligned}
  \end{equation*}
  \caption{Checking Expressions, $checkExpr$}
\end{figure}

\subsubsection{$inferExpr$}

$inferExpr$ takes 4 arguments, which is the same first 4 arguments taken in by $checkExpr$. Unless an error occurs, it returns the inferred type of the input expression.

\begin{figure}[H]
  \begin{equation*}
    \begin{aligned}
      inferExpr \: k \: \rho \: \Gamma \: (e_1 \: e_2)                & = & eval \: B^{\rho:(x,eval \: e_2^{\rho})}                                                        \\
                                                                      &   & \textrm{ where } inferExpr \: k \: \rho \: \Gamma \: e_1 = Pi \: x \: v_A \: B^{\rho} \: \land \\
                                                                      &   & checkExpr \: k \: \rho \: \Gamma \: e_2 \: v_A                                                 \\
      inferExpr \: k \: \rho \: \Gamma \: e_1 \: (e_2 \: (e_3 \dots)) & = & v                                                                                              \\
                                                                      &   & \textrm{ where } inferExpr \: k \: \rho \: \Gamma \: (e_1 \: e_2) \: (e_3 \dots) = v           \\                                                      
      inferExpr \: k \: \rho \: \Gamma \: x                           & = & \textrm{value of x in } \Gamma                                                                 \\
      inferExpr \: k \: \rho \: \Gamma \: f                           & = & v                                                                                              \\
                                                                      &   & \textrm{ where } \Sigma \: f = (v,\_,\_) \textrm{ in the Signature.}                           \\
      inferExpr \: k \: \rho \: \Gamma \: c                           & = & v                                                                                              \\
                                                                      &   & \textrm{ where } \Sigma \: c = v \textrm{ in the Signature.}                                   \\
      inferExpr \: k \: \rho \: \Gamma \: D                           & = & v                                                                                              \\
                                                                      &   & \textrm{ where } \Sigma \: D = (v,\_) \textrm{ in the Signature.}                              \\                                            
    \end{aligned}
  \end{equation*}
  \caption{Inferring Expressions, $InferExpr$}
\end{figure}

\subsubsection{$eqVal$}

To check if values $v_1$ and $v_2$ are equal, $eqVal$ takes 3 arguments:

\begin{enumerate}
  \item $k$, the generic value being examined.
  \item $v_1$
  \item $v_2$
\end{enumerate}

If $v_1$ does not equal to $v_2$, an error occurs. Unless an error occurs, it returns a unit.

\begin{figure}[H]
  \begin{equation*}
    \begin{aligned}
      eqVal \: k \: (v \: (v_1 \dots v_n)) \: (w \: (w_1 \dots w_n))                       & = & eqVal \: k \:v \: w \: \land                                                                     \\                                                                  
                                                                                           &   & eqVal \: k \: v_j \: w_j, \: \forall j \in \: \{1 \dots n\}                                      \\
      eqVal \: k \: (Pi \: x_1 \: v_1 \: b_1^{\rho}) \: (Pi \: x_2 \: v_2 \: b_2^{\Gamma}) & = & eqVal \: k \: v_1 \: v_2 \: \land                                                                \\                                                
                                                                                           &   & eqVal \: (k+1) \: (eval \: b_1^{\rho \: : \: (x_1,k)}) \: (eval \: b_2^{\Gamma \: : \: (x_2,k)}) \\
      eqVal \: k \: (Lam \: x_1 \: e_1^{\rho}) \: (Lam \: x_2 \: e_2^{\Gamma})             & = & eqVal \: (k+1) \: (eval \: e_1^{\rho \: : \: (x_1,k)}) \: (eval \: e_2^{\Gamma \: : \: (x_2,k)}) \\
      eqVal \: k \: v_1 \: v_2, v_1,v_2 \in \textrm{atomic values}                         & = & v_1 = v_2                                                                                        \\
    \end{aligned}
  \end{equation*}
  \caption{Equality of Values, $eqVal$}
\end{figure}

\subsection{Type Checking of Data Types}

In this section I describe how data type declarations are type checked. See \emph{$checkDataType.hs$}.

A data type $\boldsymbol{D}$, parameterized by parameters $\boldsymbol{p_1 \dots p_n}$, indexed over $\boldsymbol{\Theta}$, inductively defined by the constructors $\boldsymbol{c_1 \dots c_n}$ with the given types, is declared as follows:

\begin{equation*}
  \begin{aligned}
    data &  & \: D \: (p_1:P_1) \dots (p_n:P_n) : \Theta \to \star       \\
         &  & c_1 : \Delta_1 \to D \: p_1 \dots p_n \: t_1^1 \dots t_m^1 \\
         &  & \dots                                                      \\
         &  & c_k : \Delta_k \to D \: p_1 \dots p_n \: t_1^k \dots t_m^k \\                                                           \\
  \end{aligned}
\end{equation*}

$D$'s constructor $c_i$ takes arguments ($\Delta_i$) and has the return type of $D \: p_1 \dots p_n \: t_1^i \dots t_m^i$ where $t_1^i \dots t_m^i \in \Theta$, the arguments of the index of $D$.

The parameters and their types, $(p_1:P_1) \dots (p_n:P_n)$, are stored in a \emph{telescope}, $\boldsymbol{\tau}$:
\begin{equation*}
  \tau = (p_1:P_1) \dots (p_n:P_n)  
\end{equation*}


For a data type to type-checked, the following conditions must hold. The functions in brackets are the respective functions checking the conditions:

\begin{enumerate}
  \item A data type family $D$ has type $\star$. ($\boldsymbol{checkDataType}$).
  \item The constructor arguments (in $\Delta_i$) have type $\star$. ($\boldsymbol{checkConType}$)
  \item The declaration must have the form such that the parameters in the result type of every constructor exactly match those of the telescope $\tau$. ($\boldsymbol{checkTarget}$)
  \item All constructors are type-checked. ($\boldsymbol{typeCheckConstructor}$)
\end{enumerate}

\subsection{Type Checking of Functions}

\subsubsection{Type Checking of Patterns}
\label{sec:typeCheckPattern}

\section{Strict Positivity Checks}
\label{sec:spos}

\section{Termination Checks}
\label{sec:termination}

\subsection{Syntactic Checks}

\subsection{Type-based Checks}

\section{Pattern Matching Coverage Checks}
\label{sec:pattern}
\end{document}
